import os
import time
import uuid
import logging
from threading import Lock

from flask import Flask, jsonify, render_template_string, request

try:
	import redis
except Exception:
	redis = None

LOG = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)


class InMemoryRedis:
	"""Tiny thread-safe in-memory replacement for the Redis operations we use.

	Not a full Redis implementation — only supports the methods needed by this app:
	- zadd(name, {member: score})
	- zremrangebyscore(name, min, max)
	- zcount(name, min, max)
	- incr(name)
	- get(name)
	"""

	def __init__(self):
		self._data = {}
		self._counters = {}
		self._lock = Lock()

	def zadd(self, name, mapping):
		with self._lock:
			if name not in self._data:
				self._data[name] = []  # list of (score, member)
			for member, score in mapping.items():
				# store score as int
				self._data[name].append((int(score), member))

	def zremrangebyscore(self, name, min_score, max_score):
		with self._lock:
			if name not in self._data:
				return 0
			before = len(self._data[name])
			self._data[name] = [t for t in self._data[name] if not (min_score <= t[0] <= max_score)]
			return before - len(self._data[name])

	def zcount(self, name, min_score, max_score):
		with self._lock:
			if name not in self._data:
				return 0
			return sum(1 for s, _ in self._data[name] if min_score <= s <= max_score)

	def incr(self, name):
		with self._lock:
			self._counters[name] = self._counters.get(name, 0) + 1
			return self._counters[name]

	def get(self, name):
		with self._lock:
			return self._counters.get(name)


def get_redis_client():
	url = os.environ.get("REDIS_URL", "redis://localhost:6379/0")
	if redis is None:
		LOG.warning("redis package not installed — using in-memory fallback")
		return InMemoryRedis()

	try:
		client = redis.from_url(url, socket_connect_timeout=2)
		# quick ping to verify connection
		client.ping()
		LOG.info("Connected to Redis at %s", url)
		return client
	except Exception as e:
		LOG.warning("Could not connect to Redis at %s — using in-memory fallback (%s)", url, e)
		return InMemoryRedis()


app = Flask(__name__)
redis_client = get_redis_client()

# Keys and settings
HITS_KEY = "hits_zset"
TOTAL_KEY = "total_hits"
WINDOW_SECONDS = int(os.environ.get("REFRESH_WINDOW_SECONDS", "60"))


@app.route("/")
def home():
	"""Record a hit and return the total and recent rate (hits per WINDOW_SECONDS)."""
	now_ms = int(time.time() * 1000)
	member = f"{now_ms}-{uuid.uuid4().hex}"

	# Add to zset and increment total
	try:
		# redis-py expects mapping {member: score}
		redis_client.zadd(HITS_KEY, {member: now_ms})
		total = redis_client.incr(TOTAL_KEY)
	except Exception:
		# In case the client does not follow redis-py API exactly
		# (our InMemoryRedis implements same method names), re-try generic calls
		redis_client.zadd(HITS_KEY, {member: now_ms})
		total = redis_client.incr(TOTAL_KEY)

	# Remove old entries and count recent
	window_start = now_ms - (WINDOW_SECONDS * 1000)
	try:
		redis_client.zremrangebyscore(HITS_KEY, 0, window_start - 1)
		recent = redis_client.zcount(HITS_KEY, window_start, now_ms)
	except Exception:
		# fallback behavior if methods aren't present
		try:
			redis_client.zremrangebyscore(HITS_KEY, 0, window_start - 1)
			recent = redis_client.zcount(HITS_KEY, window_start, now_ms)
		except Exception:
			recent = 0

	rate_per_minute = recent  # hits in last WINDOW_SECONDS (default 60)

	# If the client accepts HTML, return a small page that auto-refreshes
	if "text/html" in request.headers.get("Accept", ""):
		html = """
		<!doctype html>
		<html>
		<head>
		  <meta charset="utf-8">
		  <title>Refresh Counter</title>
		  <meta http-equiv="refresh" content="5">
		</head>
		<body>
		  <h1>Refresh Counter</h1>
		  <p>Total hits: <strong>{{ total }}</strong></p>
		  <p>Hits in last {{ window }} seconds: <strong>{{ recent }}</strong></p>
		  <p>Redis URL: <code>{{ redis_url }}</code></p>
		  <p>Send a request with curl for JSON: <code>curl -H "Accept: application/json" /</code></p>
		</body>
		</html>
		"""
		return render_template_string(html, total=total, recent=rate_per_minute, window=WINDOW_SECONDS, redis_url=os.environ.get("REDIS_URL", "redis://localhost:6379/0"))

	return jsonify({
		"total_hits": int(total),
		"hits_in_last_window": int(rate_per_minute),
		"window_seconds": WINDOW_SECONDS,
	})


@app.route("/health")
def health():
	return jsonify({"status": "ok"})


if __name__ == "__main__":
	# Use port 5000 by default
	port = int(os.environ.get("PORT", "5000"))
	app.run(host="0.0.0.0", port=port)

